title=Java classes and objects
type=post
date=2024-01-10
tags=java, java-classes, oop, objects
status=published
summary=A class is a concept from Object-Oriented Programming (OOP) that allows us to represent real-world concept and entities in our programs. Objects are instances of those classes.

ogAuthor=Asiel Leal Celdeiro
~~~~~~

<h2>What are Java classes and objects?</h2>

<p>
    To put it simple, a <strong>Java class</strong> is a "form of classification". It is a concept from
    <em>Object-Oriented Programming (OOP)</em> that allows us to "classify" (or group together) a type of
    <em>object(s)</em> &mdash;another concept from OOP&mdash; An <strong>object</strong> represents a specific instance
    of a class. With classes and objects we can represent real-world concepts and entities in our programs as well as
    their interactions.
</p>
<p>
    For instance, in a program called <em>ZooManager</em> we could have the following classes: <code>Animal</code>,
    <code>Cage</code>, <code>Food</code>, and <code>ZooKeeper</code>. Likewise, the specific animal, cage, food and
    zookeeper <em>instances</em> that are present in the Zoo we're managing would be the objects instantiated during
    the execution of the program. In this case, examples of instances would be <code>teo</code> (a tiger),
    <code>cage1</code> (a cage), <code>meat</code> (food), and <code>john</code> (a zookeeper).
</p>

<h3>How do we decide which classes to define in our program?</h3>

<p>
    Classes define common <em>properties</em> and <em>behaviors</em> for the objects they represent. For example, the
    <code>Animal</code> class would have the following properties:
</p>
<ul>
    <li><code>name</code></li>
    <li><code>energy</code></li>
</ul>

<p>and the following behaviors</p>
<ul>
    <li>
        <code>move</code> (if an animal moves, it consumes energy, the <code>energy</code> property decreases)
    </li>
    <li>
        <code>eat</code> (if an animal eats, it recovers energy, the <code>energy</code> property increases)
    </li>
</ul>

<p>
    So, when we identify a collection of objects in our business domain that share the same properties and behaviors,
    we are usually in the presence of a class to be defined in our program. Sometimes it can be obvious, like
    knowing we'll need a class called <code>Animal</code> in our ZooManager program, but sometimes it's more difficult
    to identify when we would benefit from the definition of a class. As we gain experience throughout the years, as
    developers/software engineers, it becomes easier to identify each case.
</p>

<h3>Syntax</h3>

<p>
    The simplest form of a class definition in Java you could find is this (<code>Animal</code> could have been any
    other name we define):
</p>
<pre>
class Animal {
}
</pre>

<p>
    But that class isn't very useful, is it? So, let's see everything we have in our power to declare and define our
    own classes.
</p>

<h3>Structure</h3>

<p>
    Let's use the chapter about classes from the
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html" target="_blank">
        Java Language Specification (JLS) for Java 21
    </a>
    to understand the anatomy of a class in Java.
    Notice you may want to check the
    <a href="https://docs.oracle.com/javase/specs/" target="_blank">JLS specific to your Java version</a>.
</p>

<p>Formally, this is the structure of a Java class:</p>
<pre>
{ClassModifier} class TypeIdentifier [TypeParameters] [ClassExtends] [ClassImplements] [ClassPermits] ClassBody
</pre>

<p>Where</p>
<ul>
    <li>
        <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ClassModifier" target="_blank"
           class="link-underline link-underline-opacity-0">
            <code>{ClassModifier}</code>
        </a>
        is one of: <code>public</code>, <code>protected</code>, <code>private</code>, <code>abstract</code>,
        <code>static</code>, <code>final</code>, <code>sealed</code>, <code>non-sealed</code>, <code>strictfp</code>.
    </li>

    <li><code>class</code> is the Java keyword used to specify we're declaring a class.</li>

    <li>
        <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-TypeIdentifier" target="_blank"
           class="link-underline link-underline-opacity-0">
            <code>TypeIdentifier</code>
        </a>
        is the name we want to give the class. In our previous example we used <code>Animal</code>.
    </li>

    <li>
        <!--https://en.wikipedia.org/wiki/List_of_typographical_symbols_and_punctuation_marks-->
        <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-TypeParameters" target="_blank"
           class="link-underline link-underline-opacity-0">
            <code>[TypeParameters]</code>
        </a>
        is a collection of <em>types</em> we can define withing angle brackets (<code>&lt;&gt;</code>). For instance,
        <code>&lt;T&gt;</code>. See
        <a href="https://docs.oracle.com/javase/tutorial/extra/generics/index.html"
           target="_blank"><em>generics</em></a>
        and <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.2" target="_blank">JLS</a>
        for more info about this.
    </li>

    <li>
        <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ClassExtends" target="_blank"
           class="link-underline link-underline-opacity-0">
            <code>[ClassExtends]</code>
        </a>
        is the portion of the class declaration where we can specify, after the keyword <code>extends</code>, the class
        (if any) from which our class is a direct child (descendant, inheritor). For instance,
        <code>extends LivingBeing</code>.
    </li>

    <li>
        <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ClassImplements" target="_blank"
           class="link-underline link-underline-opacity-0">
            <code>[ClassImplements]</code>
        </a>
        is the portion of the class declaration where we can list, after the keyword <code>implements</code>, the
        <a href="https://docs.oracle.com/javase/tutorial/java/concepts/interface.html" target="_blank">
            interfaces
        </a>
        (if any) whose behavior our class implements. For instance, <code>implements MovingBeing, Eater</code>.
    </li>

    <li>
        <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ClassPermits" target="_blank"
           class="link-underline link-underline-opacity-0">
            <code>[ClassPermits]</code>
        </a>
        is used when the <code>sealed</code> modifier is specified, and it indicates, after the keyword
        <code>permits</code>, the other classes (if any) that are allowed to extend our class. For example,
        <code>permits Tiger, Ostrich, Bear</code>.
    </li>

    <li>
        and,
        <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ClassBody" target="_blank"
           class="link-underline link-underline-opacity-0">
            <code>ClassBody</code>
        </a>,
        <!--https://www.compart.com/en/unicode/html-->
        is the <em>body</em> of our class, including the curly braces (&lcub;&rcub;). See next section.
    </li>
</ul>

<h4>Class body</h4>

<p>
    In short, this is the structure of the class body (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ClassBodyDeclaration" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>{ClassBodyDeclaration}</code>
    </a>):
</p>
<pre>
{
    ClassMemberDeclaration
    InstanceInitializer
    StaticInitializer
    ConstructorDeclaration
}
</pre>

<p>
    Let's see what these elements are, along with some examples.
</p>

<h5>Members</h5>

<p>
    With <em>members</em> (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ClassMemberDeclaration"
       target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>ClassMemberDeclaration</code>
    </a>
    ), we refer to <em>fields</em> (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-FieldDeclaration" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>FieldDeclaration</code>
    </a>
    ), <em>methods</em> (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-MethodDeclaration" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>MethodDeclaration</code>
    </a>
    ), <em>nested classes</em> (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ClassDeclaration" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>ClassDeclaration</code>
    </a>
    ), and <em>nested interfaces</em> (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-InterfaceDeclaration" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>InterfaceDeclaration</code>
    </a>
    ).
    The first two are the respective <em>properties</em> and <em>behaviors</em> that we were referring to initially.
    The other two are covered in next sections, along with <code>InstanceInitializer</code> and
    <code>StaticInitializer</code>.

</p>

<p>Let's see fields and methods.</p>

<h6>Fields</h6>

<p>
    Fields are properties, attributes that characterize our classes, they hold the state of the objects created from
    our classes and are useful for storing the objects information during runtime.
</p>
<p>
    We saw already some examples of properties for our mentioned <code>Animal</code> class. Now, let's see how we can
    actually write that in our code. Let's enhance our <code>Animal</code> class with some fields:
</p>
<pre>
class Animal {
    String name;
    int energy;
}
</pre>

<h6>Methods</h6>

<p>
    Methods define the behavior of the objects, they specify what "actions" the objects can do during the execution
    of our program, they define the
    <a href="https://en.wikipedia.org/wiki/API" target="_blank">
        API
    </a>
    through which we (technically speaking, other objects) can interact with them. They can do two things: return
    information about the object, and/or modify it, that's it, modify the internal state of the object.
</p>

<p>
    Let's see how we can define the actions our <code>Animal</code> objects can do:
</p>
<pre>
class Animal {
    String name;
    int energy;

    void move() {
        energy--;
        System.out.println(name + " moved");
    }

    void eat() {
        energy++;
        System.out.println(name + " ate");
    }
}
</pre>

<p>
    In this example, the method <code>move</code> decreases the <em>energy</em> value and prints the name of the animal
    that moved (i.e.: <code>teo moved</code>).
</p>
<p>
    The method <code>eat</code> does the opposite: it increases the <em>energy</em> value, and also prints the name of
    the animal that ate (i.e.: <code>teo ate</code>).
</p>

<h5>Constructors</h5>

<p>So far, we've talked a lot about Java classes, but not so much about the objects.</p>
<p>
    Just to make sure we understand the concept of <em>object</em>, if we were to make an analogy, we could say that
    <em>Woman</em> is a class, while <em>Ana</em> is an object. Similarly, <em>Man</em> is a class, and <em>John</em>
    is an object.
</p>
<p>
    Now, let's see how we can create objects in our programs. Java provides us with something called
    <em>constructors</em> (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-ConstructorDeclaration"
       target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>ConstructorDeclaration</code>
    </a>
    ). They are a "special" piece of code inside the body of our class that allow us to <em>instantiate</em>,
    <em>create</em> objects from a class definition.
</p>

<p>
    This is the structure of the constructor. Pay special attention; it looks similar to a method, but it lacks return
    type:
</p>
<pre>
    {ConstructorModifier} ConstructorDeclarator [Throws] ConstructorBody
</pre>

<p>
    But, it can be better understood with an example, so let's see it in action in our <code>Animal</code> class.
</p>
<pre>
class Animal {
    String name;
    int energy;

    Animal(String name) {   // &lt;-- Constructor added
        this.name = name;
        energy = 100;
    }

    // rest of the code omitted for brevity...
}
</pre>

<p>
    Here we've created a constructor that accepts a <code>name</code> argument and assigns it to the <code>name</code>
    field. It also initializes the <code>energy</code> field with a value of <code>100</code>.
</p>

<blockquote class="text-muted">
    Actually, there are other ways to create objects, but, to keep it simple, they're not covered here. If you feel
    curious about it, you can read more about
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html#forName(java.lang.String)"
       target="_blank" class="link-underline link-underline-opacity-0">
        <code>Class.forName(String className)</code>
    </a>,
    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#clone()"
       target="_blank" class="link-underline link-underline-opacity-0">
        <code>Object.clone()</code>
    </a>, and
    <a href="https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html" target="_blank">
        <em>Deserialization</em>
    </a>.
</blockquote>

<p>
    Up to here, we've defined the means to create an object of type <code>Animal</code>, but, how do we actually
    instantiate one?
</p>
<p>
    Simple, we use the
    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>new</code>
    </a>
    keyword.
</p>
<pre>
    Animal teo = new Animal("Teo");
</pre>

<h5>Nested classes</h5>

<p>
    We've mentioned earlier that we can have nested classes, also known as
    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank">
        inner classes
    </a>
    as a members of another class. But how does that actually look like? Well, it's quite simple once we have understood
    fields and methods because their declaration follow the same principle: it's a code structure that "belongs" to the
    class where they're declared. Let's see an example.
</p>

<p>
    Let's suppose we want to represent each part of the body of an animal with a class. And then each animal would
    be formed by its parts &mdash;granted, this is a contrived example, just to make the point&mdash;
</p>
<p> At this point, we have two options:</p>
<ol>
    <li>
        Create two independent classes, each in its own <code>.java</code> file (<code>Animal.java</code> and
        <code>BodyPart.java</code>)
    </li>
    <li>
        Create one top level class (<code>Animal</code>), and one inner class (<code>BodyPart</code>), both in one
        <code>.java</code> file called <code>Animal.java</code>
    </li>
</ol>
<p>
    How do we decide which option is better? Obviously "better" always depends on your specific use case, but for this
    example, let's say a <code>BodyPart</code> doesn't make any sense without an <code>Animal</code>, so it's better
    to model the solution as if it's a member of <code>Animal</code>. In this case we declare another class "inside"
    <code>Animal</code>, with all the same components we've discussed so far.
</p>
<pre>
class Animal {
    class BodyPart {      // &lt;-- inner class added
        String partName;
        double weight;
    }

    /**
     * Holds the information for each body part of this animal.
     */
    Collection&lt;BodyPart&gt; bodyParts;

    // rest of the code omitted for brevity...
}
</pre>

<h5>Nested interfaces</h5>

<p>
    It's difficult to explain what a <em>nested interface is</em> without knowing what's a Java
    <a href="https://docs.oracle.com/javase/tutorial/java/concepts/interface.html" target="_blank">
        interface
    </a>.
    To keep it simple, and focus on classes, which is the topic of the article, I'll oversimplify it: it's basically
    a group of related methods with empty bodies, and its declaration is quite similar to that of a class. For example,
    this is an interface called <code>MovingBeing</code>:
</p>
<pre>
interface MovingBeing {
    void move();
}
</pre>

<p>
    Now, if we were to declare this interface as a member of the <code>Animal</code> class, we just need to follow the
    same logic we used to declare the inner class <code>BodyPart</code>:
</p>
<pre>
class Animal {
    interface MovingBeing {     // &lt;-- inner interface added, not very useful now
        void move();
    }

    // rest of the code omitted for brevity...
}
</pre>

<h5>Instance and static initializer</h5>

<p>
    There are two elements of the body of the class we haven't covered yet: instance initializers (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-InstanceInitializer" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>InstanceInitializer</code>
    </a>
    )
    and static initializers (
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-StaticInitializer" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>StaticInitializer</code>
    </a>
    ).
</p>

<p>
    They both are a
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-Block" target="_blank">block</a>
    of code where some <em>initialization</em> happens. The only difference between them is that the instance
    initializer is tied to the life-cycle of the object being created; hence, the code block is executed once for each
    object created. The static initializer, on the other hand, is executed only when the class is loaded (usually only
    once during the program execution). This is more related to the concept of
    <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html" target="_blank"
       class="link-underline link-underline-opacity-0">
        <code>static</code>
    </a>
    members (see
    <a href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.3.1.1" target="_blank">JLS</a>).
</p>
<p>
    Let's see them in an example.
</p>

<h6>Instance initializers</h6>

<p>
    Let's suppose we want to move the initialization of the field <code>energy</code> out of the constructor. We can do
    it by placing the expression <code>energy = 100;</code> inside an instance initializer:
</p>
<pre>
class Animal {
    String name;
    int energy;

    {
        energy = 100;       // &lt;-- initialization moved to this instance initializer
    }

    Animal(String name) {
        this.name = name;
    }

    // rest of the code omitted for brevity...
}
</pre>

<h6>Static initializers</h6>

<p>
    Now, let's suppose that we want to have a field inside the <code>Animal</code> class called
    <code>perceivedTemperature</code>, which indicates the environment temperature perceived by the animals. In this
    case we don't want to have a separate value for each animal, because we can say this temperature is the same
    for every animal &mdash;again, this is a contrived example, for demonstration purposes&mdash;
</p>
<p>
    To store such field we should not do it with an instance field, but with a static one. This way, when the field is
    modified, we get the same value, regardless of the <code>Animal</code> instance the value is being accessed from. It
    would look like this:
</p>
<pre>
class Animal {
    static double perceivedTemperature;

    // rest of the code omitted for brevity...
}
</pre>

<p>
    Now, we would like to initialize it in an instance initializer block, how do we do it? Simple:
</p>
<pre>
class Animal {
    static double perceivedTemperature;

    static {
        perceivedTemperature = 32.4d;
    }

    // rest of the code omitted for brevity...
}
</pre>

<h2>The <em>.java</em> file</h2>

<p>Where do we write our classes? Inside <code>.java</code> files.</p>

<p>
    Most of the time, each class is defined in its own <code>.java</code> file. Such class is called a
    <em>top level</em> class (type).
</p>

<p>
    But it's not mandatory to have only one top level type in a <code>.java</code> file. We can define several of them,
    as long as <em>at most one</em> of them is <code>public</code>. Put in another way: we can not declare more than
    one top level type (meaning, they're <code>public</code>) in the same <code>.java</code> file.
</p>

<h3>Putting it all together</h3>

<p>Let's see some examples where we apply all the knowledge we've learned.</p>

<h4>Examples</h4>

<h5>A public class with two fields, two methods, and one constructor</h5>

<p>We saw this one already, but for the sake of completeness, let's review it:</p>

<pre>
public class Animal {
    String name;
    int energy;

    Animal(String name) {
        this.name = name;
        energy = 100;
    }

    void move() {
        energy--;
        System.out.println(name + " moved");
    }

    void eat() {
        energy++;
        System.out.println(name + " ate");
    }
}
</pre>


<h5>A public class with two fields, one instance initializer, and one static initializer</h5>
<pre>
public class Animal {
    String name;
    static double perceivedTemperature;

    {
        name = "Leo";
    }
    static {
        perceivedTemperature = 32.4d;
    }
}
</pre>

<h5>A package-private class, one private static inner class, and one public static inner interface</h5>
<blockquote>
    Side note: interfaces are <code>static</code> by default, but I'm putting it here for demonstration purposes only.
</blockquote>
<pre>
class Animal {
    private static class BodyPart {
        String partName;
    }
    public static interface MovingBeing {
        void move();
    }
}
</pre>

<h5>A sealed class that permits another final class to extend it</h5>
<pre>
sealed class Animal permits Tiger {
}
final class Tiger extends Animal {
}
</pre>

<h5>A sealed class that permits another non-sealed class to extend it</h5>
<pre>
sealed class Animal permits Tiger {
}
non-sealed class Tiger extends Animal {
}
</pre>

<h2>Could we implement our programs entirely without classes?</h2>

<p>
    Certainly. Technically speaking, we don't need to create our own classes to implement a business logic. But, by
    doing so, we can structure better our code and re-use it more effectively, we can achieve more robust and secure
    software and more adaptable to future changes. The enormous benefits of designing our code around OOP concepts
    such as classes and objects pay off immensely in the long term.
</p>

<h2>Final thoughts</h2>
<p>
    There are much more details to learn about Java classes and objects; we barely touched the scratch here, but
    hopefully, the content and links I've shared here are a good start for you to continue learning on your own and
    apply that knowledge in building high quality software.
</p>
