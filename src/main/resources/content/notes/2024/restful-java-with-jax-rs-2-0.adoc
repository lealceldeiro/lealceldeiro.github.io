= RESTful Java with JAX-RS 2.0, 2nd Edition
Asiel Leal_Celdeiro
2024-02-01
:icons: font
:jbake-fontawesome: true
:jbake-type: booknote
:jbake-status: published
:jbake-tags: java, jax-rs, webservice
:jbake-read: progress
:jbake-summary: Recommended by the official docs from https://resteasy.dev/books, "RESTful Java with JAX-RS 2.0" is \
an excellent guide to start building RESTful services in Java.
:jbake-authors: Bill Burke
:jbake-publisher: O'Reilly Media, Inc.
:jbake-published: November 2013
:jbake-amazon_link: https://a.co/d/15qvYGA
:jbake-orreilly_link: https://www.oreilly.com/library/view/restful-java-with/9781449361433/
:jbake-og_img: notes/2024/images/restful-java-with-jax-rs-2-0.jpg
:jbake-image_src: notes/2024/images/restful-java-with-jax-rs-2-0.jpg
:jbake-image_alt: Image of the book cover: RESTful Java with JAX-RS 2.0, 2nd Edition
:jbake-og_author: Asiel Leal Celdeiro
:jbake-author_handle: lealceldeiro
:jbake-author_profile_image: /img/author/lealceldeiro.png

Main notes taken from the book https://a.co/d/15qvYGA["RESTful Java with JAX-RS 2.0, Second Edition"^]
by Bill Burke.
Copyright 2014 Bill Burke, 978-1-449-36134-1

Source code at: https://github.com/oreillymedia/restful_java_jax-rs_2_0

_Note: As this is rather an old book, it's advisable to always verify if there are newer, more modern alternatives for solutions explained here; for instance, when Java clients or options to secure Java application are mentioned._

'''

Java API for RESTful web services (JAX-RS) aims to make development of RESTful web services in Java simple and
intuitive.

== Chapter 1: Introduction to REST

Architectural principles of the REpresentational State Transfer (REST):

* Addressable resources
* A uniform, constrained interface
* Representation-oriented
* Communicate statelessly
* Hypermedia As The Engine Of Application State (HATEOAS)

Example of an HTTP request performed by the browser:

[source,console]
----
GET /resteasy HTTP/1.1
Host: jboss.org
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language:
en-us,en;q=0.5
Accept-Encoding:
gzip,deflate
----

To the previous request, the response could be:

[source,console]
----
HTTP/1.1 200 OK
X-Powered-By: Servlet 2.4; JBoss-4.2.2.GA
Content-Type: text/html
<head>
<title>JBoss RESTEasy Project</title>
</head>
<body>
<h1>JBoss RESTEasy</h1>
<p>JBoss RESTEasy is an open source implementation of the JAX-RS specification...
----

URI characters are encoded following these rules:

* The characters `a-z`, `A-Z`, `0-9`, `.`, `-`, `*`, and `_` remain the same
* The space character is converted to `+`
* The other characters are first converted into a sequence of bytes using a specific encoding scheme.
Next, a two-digit hexadecimal number prefixed by `%` represents each byte

`GET` is a read-only operation.
It is used to query the server for specific information.
It is both an idempotent and safe operation.

`PUT` requests that the server store the message body sent with the request under the location provided in the HTTP
message.
It is usually modeled as an insert or update and it's also idempotent.

`DELETE` is used to remove resources.
It is idempotent as well.

`POST` is non-idempotent and unsafe operation.
Each POST method is allowed to modify the service in a unique way.
We may or may not send information with the request.
We may or may not receive information from the response.

`HEAD` is exactly like `GET` except that instead of returning a response body, it returns only a response code and
any headers associated with the request.

`OPTIONS` is used to request information about the communication options of the resource we're interested in.
It allows the client to determine the capabilities of a server and a resource without triggering any resource action
or retrieval.

In a RESTful system, the complexity of the client-server interaction is within the representations being passed
back and forth.
These representations could be XML, JSON, YAML, or any other format designed for this purpose.

HTTP uses the `Content-Type` header to tell the client or server what data format it is receiving.
Its value string is in the Multipurpose Internet Mail Extension (MIME) format.
The MIME format is basic: `type/subtype;name=value;name=value...`.
For example:

[source,console]
----
text/plain
text/html
application/xml
text/html; charset=iso-8859-1
----

== Chapter 2: Designing RESTful Services

`PUT` and `POST` are required by their specification to send a response code of 201, “Created,” if a new resource was
created on the server as a result of the request.

The `Location` header in the response message provides a URI to the client for a created resource,
so it knows where to further interact with the resource that was just created
(i.e., if the client wanted to update the resource).

For `DELETE`, the HTTP specification requires that we send a response code of `200 OK`,
and a response message body or a response code of `204 No Content`, without any response body.

== Chapter 3: First JAX-RS Service

JAX-RS is a framework that focuses on applying Java annotations to plain Java objects.
It has annotations to bind specific URI patterns and HTTP operations to individual methods in the Java classes.

A JAX-RS service is a Java class that uses JAX-RS annotations to bind and map specific incoming HTTP requests to
Java methods that can service these requests.

In vanilla JAX-RS, services can either be singletons or per-request objects.
A _singleton_ means that one and only one Java object services HTTP requests.
_Per-request_ means that a Java object is created to process each incoming request and is thrown away at the
end of that request.

Example:

[source,java]
----
import jakarta.ws.rs.Path;

@Path("/resource-uri")
public class ResourceService {
    // ... logic omitted for brevity
}
----

IMPORTANT: https://jakarta.ee/specifications/restful-ws/3.0/apidocs/jakarta/ws/rs/path[`@Path`^, role=link-underline link-underline-opacity-0],
under package `jakarta.ws.rs`, was formerly under the package `jakarta.ws.rs`.
See https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#uritemplates[`URI Templates`^]
and https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#changes-since-2.1-release[Changes since version 2.1^] for more info.

Example of a service to create a resource:

[source,java]
----
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import java.io.InputStream;

@POST
@Consumes("application/xml")
public Response createResource(InputStream is) {
    // ... code omitted for brevity
}
----

Example of a service to get a resource:

[source,java]
----
import jakarta.ws.rs.core.StreamingOutput;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;

@GET
@Path("{id}")
@Produces("application/xml")
public StreamingOutput getResource(@PathParam("id") int id) {
    // code omitted for brevity
}
----

TIP: In general, we don't use the `StreamingOutput` interface to output responses.
Instead, we would use some of the content handlers provided by JAX-RS
that can automatically convert Java objects straight into the data format being sent across the wire.

Example of a service to update a resource:

[source,java]
----
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.PathParam;
import java.io.InputStream;

@PUT
@Path("{id}")
@Consumes("application/xml")
public void updateResource(@PathParam("id") int id, InputStream is) {
    // code omitted for brevity
}
----

In the previous example, `IntputSteram is` is not annotated with a JAX-RS annotation,
so it's considered a representation of the body of the incoming message.

An alternative implementation to having the JAX-RS annotations applied directly to the methods than handle
the business logic, is to have an interface where the methods are defined along with the annotations.
Then a class that implements the interface would implement the methods defined by the interface, without needing to
have the annotations applied to the methods in the concrete class.

In case it's needed, any of the JAX-RS annotations applied to the interface can be applied again to the methods in the
concrete class (and re-define the annotation configuration).
Although, re-applying annotation on the concrete class is not advisable because the code is harder to reason about and
maintain.

== Chapter 4: HTTP Method and URI Matching

The full ist of JAX-RS annotations that map to specific HTTP operations are:

* `@jakarta.ws.rs.GET`
* `@jakarta.ws.rs.PUT`
* `@jakarta.ws.rs.POST`
* `@jakarta.ws.rs.DELETE`
* `@jakarta.ws.rs.HEAD`

The value of the `@Path` annotation is an expression that denotes a relative URI to the
context root of the JAX-RS application.

The JAX-RS specification has defined strict sorting and precedence rules for matching URI expressions
and is based on a _most specific match wins_ algorithm.

The JAX-RS provider gathers the deployed URI expressions and sorts them based on the following logic:

1. The primary key of the sort is the number of literal characters in the full URI matching pattern.
The sort is in descending order.
2. The secondary key of the sort is the number of template expressions embedded within the pattern,
that is, i.e., `++{id}++` or `++{id : .+}++`.
This sort is also in descending order.
3. The tertiary key of the sort is the number of non-default template expressions.
A default template expression is one that does not define a regular expression, that is, i.e., `++{id}++`.

Example of URIs, sorted by this logic:

[source,console]
----
/resource/{id}/{name}/address   // <1>
/resource/{id : .+}/address     // <2>
/resource/{id}/address          // <3>
/resource/{id : .+}             // <4>
----
<1> Expressions 1 to 3 all have the same number of literal characters,
but expression 1 comes first because of the second sorting rule:
it has more template expressions embedded within the pattern.
<2> Expression 2 is sorted ahead of 3 because of the third sorting rule;
it has a template pattern that is a regular expression while expression 3 doesn't have one.
<3> Expression 3 is sorted ahead of expression 4 because it has more literal characters tan expression 4.
<4> Expressions 1 to 3 come first because they all have more literal characters than expression 4.

Allowable and reserved characters:

* The US-ASCII alphabetic characters `a-z` and `A-Z` are allowable.
* The decimal digit characters `0-9` are allowable.
* All these other characters are allowable: `_-!.~'()*`.
* These characters are allowed but are reserved for URI syntax: `,;:$&+=?/\[]@`.

All other characters must be encoded using the `%` character followed by a two-digit hexadecimal number.
This hexadecimal number corresponds to the equivalent hexadecimal character in the ASCII table.

_Matrix parameters_ are name-value pairs embedded within the path of a URI string. Example:

[source,console]
----
https://domain.com/resources/r1;color=black/333
----

They come after a URI segment and are delimited by the `;`.
In the previous example that'd be `color=black/333`.
The name is `color` and the value is `black`.

Matrix parameters are different from query parameters,
as they represent attributes of certain URI segments and are used for identification purposes.
They could be seen as adjectives.
Query parameters, on the other hand, always come at the end of the URI
and always pertain to the full resource we're referencing.
They are ignored when matching incoming requests to JAX-RS resource methods,
and it's illegal to specify them within an `@Path` expression.

JAX-RS also allows us to dynamically dispatch requests through _subresource locators_.
These are Java methods annotated with `@Path`, but with no HTTP method annotation, like `@GET`, applied to them.
These methods return an object that is itself a JAX-RS annotated service that knows how to dispatch the remainder of
the request.

Example:

[source,java]
----
// imports omitted for brevity

@Path("/resource")
public class RootResource {                                         // <1>
    @Path("{id}-x")                                                 // <2>
    public ResourceX getX(@PathParam("id") String xId) {
        return locateResourceX(xId);                                // <3>
    }

    protected ResourceX locateResourceX(String xId) {
        // code omitted for brevity
    }
}
----
<1> The `RootResource` class is our root resource,
and it does not service any HTTP requests directly, it serves as a _locator_.
<2> It processes the _x_ identifier part of the URI (`id`)
<3> Then it locates the identified _x_ resource and returns an instance of the `ResourceX`

The JAX-RS provider uses this `ResourceX` instance to service the remainder of the request:

[source,java]
----
// imports omitted for brevity

// no need to annotate this resource with `@Path` as the locator will create an instance of it
// and the JAX-RS framework will know how to handle the rest of the request processing
public class ResourceX {
    private Map<Integer, Customer> xResources;
    private AtomicInteger idCounter = new AtomicInteger();

    public ResourceX(Map<Integer, Customer> xResources) {
        this.xResources = xResources;
    }

    @POST
    @Consumes("application/xml")
    public Response createResource(InputStream is) {
        // code omitted for brevity
    }

    @GET
    @Path("{id}")
    @Produces("application/xml")
    public StreamingOutput getResource(@PathParam("id") int id) {
        // code omitted for brevity
    }

    @PUT
    @Path("{id}")
    @Consumes("application/xml")
    public void updateResource(@PathParam("id") int id, InputStream is) {
        // code omitted for brevity
    }
}
----

Following along with the previous example: if a client sends `GET /resource/blue-x/333`,
the JAX-RS provider will first match the expression on the method `RootResource.getX`.
Then, it will match and process the remaining part of the request with the method `ResourceX.getResource()`.

JAX-RS provides an even more flexible _full dynamic dispatching_, where the located subresource can be "dynamically"
defined in the root resource.
Following along with the previous example, we could evolve it as follows:

[source,java]
----
// imports omitted for brevity

@Path("/resource")
public class RootResource {
    @Path("{id}-x")
    public IResourceX getX(@PathParam("id") String xId) {           // <1>
        return locateResourceX(xId);
    }

    protected IResourceX locateResourceX(String xId) {
        if (/*some condition*/) {
            return locateResourceX1(xId);
        }
        return locateResourceX2(xId);
    }

    private ResourceX1 locateResourceX1(String xId) {
        // code omitted for brevity
    }

    private ResourceX2 locateResourceX2(String xId) {
        // code omitted for brevity
    }
}

interface IResourceX {
    // code omitted for brevity
}
class ResourceX1 implements IResourceX {
    // code omitted for brevity
}
class ResourceX2 implements IResourceX {
    // code omitted for brevity
}
----
<1> Now, instead of a specific resource (concrete class), we return an interface.
JAX-RS will introspect the instance returned to figure out how to dispatch the request.

== Chapter 5: JAX-RS Injection

== Chapter 6: JAX-RS Content Handlers

== Chapter 7: Server Responses and Exception Handling

== Chapter 8: JAX-RS Client API

== Chapter 9: HTTP Content Negotiation

== Chapter 10: HATEOAS

== Chapter 11: Scaling JAX-RS Applications

== Chapter 12: Filters and Interceptors

== Chapter 13: Asynchronous JAX-RS

== Chapter 14: Deployment and Integration

== Chapter 15: Securing JAX-RS

== Chapter 16: Alternative Java Clients
