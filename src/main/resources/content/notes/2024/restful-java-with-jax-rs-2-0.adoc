= RESTful Java with JAX-RS 2.0, 2nd Edition
Asiel Leal_Celdeiro
2024-02-01
:jbake-type: booknote
:jbake-status: published
:jbake-tags: java, jax-rs, webservice
:jbake-read: progress
:jbake-summary: Recommended by the official docs from https://resteasy.dev/books, "RESTful Java with JAX-RS 2.0" is \
an excellent guide to start building RESTful services in Java.
:jbake-authors: Bill Burke
:jbake-publisher: O'Reilly Media, Inc.
:jbake-published: November 2013
:jbake-amazon_link: https://a.co/d/15qvYGA
:jbake-orreilly_link: https://www.oreilly.com/library/view/restful-java-with/9781449361433/
:jbake-og_img: notes/2024/images/restful-java-with-jax-rs-2-0.jpg
:jbake-image_src: notes/2024/images/restful-java-with-jax-rs-2-0.jpg
:jbake-image_alt: Image of the book cover: RESTful Java with JAX-RS 2.0, 2nd Edition
:jbake-og_author: Asiel Leal Celdeiro
:jbake-author_handle: lealceldeiro
:jbake-author_profile_image: /img/author/lealceldeiro.png

Main notes taken from the book https://a.co/d/15qvYGA["RESTful Java with JAX-RS 2.0, Second Edition"^]
by Bill Burke.
Copyright 2014 Bill Burke, 978-1-449-36134-1

Source code at: https://github.com/oreillymedia/restful_java_jax-rs_2_0

_Note: As this is rather an old book, it's advisable to always verify if there are newer, more modern alternatives for solutions explained here; for instance, when Java clients or options to secure Java application are mentioned._

'''

Java API for RESTful web services (JAX-RS) aims to make development of RESTful web services in Java simple and
intuitive.

== Chapter 1: Introduction to REST

Architectural principles of the REpresentational State Transfer (REST):

* Addressable resources
* A uniform, constrained interface
* Representation-oriented
* Communicate statelessly
* Hypermedia As The Engine Of Application State (HATEOAS)

Example of an HTTP request performed by the browser:

[source,console]
----
GET /resteasy HTTP/1.1
Host: jboss.org
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language:
en-us,en;q=0.5
Accept-Encoding:
gzip,deflate
----

To the previous request, the response could be:

[source,console]
----
HTTP/1.1 200 OK
X-Powered-By: Servlet 2.4; JBoss-4.2.2.GA
Content-Type: text/html
<head>
<title>JBoss RESTEasy Project</title>
</head>
<body>
<h1>JBoss RESTEasy</h1>
<p>JBoss RESTEasy is an open source implementation of the JAX-RS specification...
----

URI characters are encoded following these rules:

* The characters `a-z`, `A-Z`, `0-9`, `.`, `-`, `*`, and `_` remain the same
* The space character is converted to `+`
* The other characters are first converted into a sequence of bytes using a specific encoding scheme.
Next, a two-digit hexadecimal number prefixed by `%` represents each byte

`GET` is a read-only operation.
It is used to query the server for specific information.
It is both an idempotent and safe operation.

`PUT` requests that the server store the message body sent with the request under the location provided in the HTTP
message.
It is usually modeled as an insert or update and it's also idempotent.

`DELETE` is used to remove resources.
It is idempotent as well.

`POST` is non-idempotent and unsafe operation.
Each POST method is allowed to modify the service in a unique way.
We may or may not send information with the request.
We may or may not receive information from the response.

`HEAD` is exactly like `GET` except that instead of returning a response body, it returns only a response code and
any headers associated with the request.

`OPTIONS` is used to request information about the communication options of the resource we're interested in.
It allows the client to determine the capabilities of a server and a resource without triggering any resource action
or retrieval.

In a RESTful system, the complexity of the client-server interaction is within the representations being passed
back and forth.
These representations could be XML, JSON, YAML, or any other format designed for this purpose.

HTTP uses the `Content-Type` header to tell the client or server what data format it is receiving.
Its value string is in the Multipurpose Internet Mail Extension (MIME) format.
The MIME format is basic: `type/subtype;name=value;name=value...`.
For example:

[source,console]
----
text/plain
text/html
application/xml
text/html; charset=iso-8859-1
----

== Chapter 2: Designing RESTful Services

`PUT` and `POST` are required by their specification to send a response code of 201, “Created,” if a new resource was
created on the server as a result of the request.

The `Location` header in the response message provides a URI to the client for a created resource,
so it knows where to further interact with the resource that was just created
(i.e., if the client wanted to update the resource).

For `DELETE`, the HTTP specification requires that we send a response code of `200 OK`,
and a response message body or a response code of `204 No Content`, without any response body.

== Chapter 3: First JAX-RS Service

JAX-RS is a framework that focuses on applying Java annotations to plain Java objects.
It has annotations to bind specific URI patterns and HTTP operations to individual methods in the Java classes.

A JAX-RS service is a Java class that uses JAX-RS annotations to bind and map specific incoming HTTP requests to
Java methods that can service these requests.

In vanilla JAX-RS, services can either be singletons or per-request objects.
A _singleton_ means that one and only one Java object services HTTP requests.
_Per-request_ means that a Java object is created to process each incoming request and is thrown away at the
end of that request.

Example:

[source,java]
----
import jakarta.ws.rs.Path;

@Path("/resource-uri")
public class ResourceService {
    // ... logic omitted for brevity
}
----

IMPORTANT: https://jakarta.ee/specifications/restful-ws/3.0/apidocs/jakarta/ws/rs/path[`@Path`^, role=link-underline link-underline-opacity-0],
under package `jakarta.ws.rs`, was formerly under the package `jakarta.ws.rs`.
See https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#uritemplates[`URI Templates`^]
and https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#changes-since-2.1-release[Changes since version 2.1^] for more info.

Example of a service to create a resource:

[source,java]
----
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import java.io.InputStream;

@POST
@Consumes("application/xml")
public Response createResource(InputStream is) {
    // ... code omitted for brevity
}
----

Example of a service to get a resource:

[source,java]
----
import jakarta.ws.rs.core.StreamingOutput;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;

@GET
@Path("{id}")
@Produces("application/xml")
public StreamingOutput getResource(@PathParam("id") int id) {
    // code omitted for brevity
}
----

TIP: In general, we don't use the `StreamingOutput` interface to output responses.
Instead, we would use some of the content handlers provided by JAX-RS
that can automatically convert Java objects straight into the data format being sent across the wire.

Example of a service to update a resource:

[source,java]
----
import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.PathParam;
import java.io.InputStream;

@PUT
@Path("{id}")
@Consumes("application/xml")
public void updateResource(@PathParam("id") int id, InputStream is) {
    // code omitted for brevity
}
----

In the previous example, `IntputSteram is` is not annotated with a JAX-RS annotation,
so it's considered a representation of the body of the incoming message.

An alternative implementation to having the JAX-RS annotations applied directly to the methods than handle
the business logic, is to have an interface where the methods are defined along with the annotations.
Then a class that implements the interface would implement the methods defined by the interface, without needing to
have the annotations applied to the methods in the concrete class.

In case it's needed, any of the JAX-RS annotations applied to the interface can be applied again to the methods in the
concrete class (and re-define the annotation configuration).
Although, re-applying annotation on the concrete class is not advisable because the code is harder to reason about and
maintain.

== Chapter 4: HTTP Method and URI Matching

The full ist of JAX-RS annotations that map to specific HTTP operations are:

* `@jakarta.ws.rs.GET`
* `@jakarta.ws.rs.PUT`
* `@jakarta.ws.rs.POST`
* `@jakarta.ws.rs.DELETE`
* `@jakarta.ws.rs.HEAD`

== Chapter 5: JAX-RS Injection

== Chapter 6: JAX-RS Content Handlers

== Chapter 7: Server Responses and Exception Handling

== Chapter 8: JAX-RS Client API

== Chapter 9: HTTP Content Negotiation

== Chapter 10: HATEOAS

== Chapter 11: Scaling JAX-RS Applications

== Chapter 12: Filters and Interceptors

== Chapter 13: Asynchronous JAX-RS

== Chapter 14: Deployment and Integration

== Chapter 15: Securing JAX-RS

== Chapter 16: Alternative Java Clients
